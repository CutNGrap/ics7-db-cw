% !TeX spellcheck = ru_RU
\chapter{Технологический раздел}
В данном разделе рассмотрены средства реализации программного продукта, приведены результаты тестирования ПО.


\section{Средства реализации} 
Для реализации ПО был выбран язык программирования C++\cite{cpp}. 

В данном языке есть все требующиеся инструменты для реализации программы.

В качестве среды разработки была выбрана среда QtCreator \cite{qtcreator}, запуск происходил через средство разработки.

\section{Реализация алгоритмов}

%\begin{center}
	
	\begin{lstlisting}[caption=Внешняя функция запуска процесса отрисовки]
void SceneManager::render(vec3 *img)const
{
	vec3 cam = scene->get_camera()->get_position();
	vec3 w = scene->get_camera()->get_direction(); // (u,v,w) basis
	vec3 u = screen_u(w);
	vec3 v = screen_v(u, w);
	for (int i = 0; i < win_x; i++)
	{
		for (int j = 0; j < win_y; j++){
			float x = tan(fov/2.) * (2 * i/(float)win_x - 1);
			float y = -tan(fov/2.) * (2 * j/(float)win_y - 1);
			vec3 dir = (w + u * x + v * y).normalized();
			img[i * win_y + j] = cast_ray(cam, dir);
		}
	}
}
	\end{lstlisting}

\begin{lstlisting}[caption=Функция испускания одного луча]
vec3 SceneManager::cast_ray(const vec3 &orig, const vec3 &dir) const{
	vec3 point, N;
	vec3 color;
	
	if (!scene_intersect(orig, dir, point, N, color)) {
		return back; // background color
	}
	
	double diffuse_light_intensity = 0.2;
	std::shared_ptr<Light> light= scene->get_light();
	
	vec3 light_dir      = ((light)->get_position() - point).normalized();
	diffuse_light_intensity  += (light)->get_intensity() * std::max(0.f, light_dir*N);
	
	vec3 c = color * diffuse_light_intensity;
	return c;
}
\end{lstlisting}

\begin{lstlisting}[caption=Функция определения факта пересечения луча с объектом сцены]
bool SceneManager::scene_intersect(const vec3 &orig, const vec3 &dir, vec3 &hit, vec3 &N, vec3 &color) const
{
	float obj_dist = std::numeric_limits<float>::max();
	double t0 = std::numeric_limits<float>::max();
	for (auto it = scene->begin(); it != scene->end(); ++it)
	{
		if ((*it)->ray_intersect(orig, dir, t0, color, N) && t0 < obj_dist)
		{
			obj_dist = t0;
			hit = orig + dir*t0;
		}
	}
	return obj_dist<max_draw;
}

\end{lstlisting}

\begin{lstlisting}[caption=Функция создания дополнительных потоков для распараллеливания процесса отрисовки]
void SceneManager::render(int threads, vec3 *img)const
{
	vec3 cam = scene->get_camera()->get_position();
	vec3 w = scene->get_camera()->get_direction();
	vec3 u = screen_u(w);
	vec3 v = screen_v(u, w);
	pthread_t *tid = (pthread_t *)malloc(threads * sizeof(pthread_t));
	thread_args_t *args = (thread_args_t *)malloc(threads * sizeof(thread_args_t));
	if (tid && args)
	{
		int delta = win_x / threads;
		int last = win_x % threads;
		for (int start = 0, end = delta + last, thread = 0; thread < threads; ++thread, start = end, end += delta)
		{
			if (thread == threads - 1)
				end = win_x;
			(args + thread)->start = start;
			(args + thread)->end = end;
			(args + thread)->img = img;
			(args + thread)->win_x = win_x;
			(args + thread)->win_y = win_y;
			(args + thread)->cam = scene->get_camera()->get_position();
			(args + thread)->scene_man = this;
			(args + thread)->fov = fov;
			(args + thread)->u =u;
			(args + thread)->w =w;
			(args + thread)->v = v;
			pthread_create(tid + thread, NULL, render_per_thread, args + thread);
		}
		for (int thread = 0; thread < threads; ++thread)
			pthread_join(tid[thread], NULL);
	}
	free(tid);
	free(args);
}
\end{lstlisting}

\begin{lstlisting}[caption=Функция работы одного потока для участия в процессе отрисовки]
void *render_per_thread(void *args)
{
	thread_args_t *arg = (thread_args_t *)args;
	vec3 cam = arg->cam;
	vec3 w = arg->w;
	vec3 u = arg->u;
	vec3 v = arg->v;
	vec3 *img = arg->img;
	int win_y = arg->win_y;
	int win_x = arg->win_x;
	double fov = arg->fov;
	int start = arg->start;
	int end = arg->end;
	const SceneManager *scene_man = arg->scene_man;
	for (int i = start; i < end; i++)
	{
		for (int j = 0; j < win_y; j++){
			float x = tan(fov/2.) * (2 * i/(float)win_x - 1);
			float y = -tan(fov/2.) * (2 * j/(float)win_y - 1);
			vec3 dir = (w + u * x + v * y).normalized();
			img[i * win_y + j] = scene_man->cast_ray(cam, dir);
		}
	}
}
\end{lstlisting}

%\end{center}

\clearpage

%\begin{center}
\begin{lstlisting}[caption=Функция создания ячеистой структуры]
	bool SceneManager::scene_intersect(const vec3 &orig, const vec3 &dir, vec3 &hit, vec3 &N, vec3 &color) const
	{
		float obj_dist = std::numeric_limits<float>::max();
		double t0 = std::numeric_limits<float>::max();
		for (auto it = scene->begin(); it != scene->end(); ++it)
		{
			if ((*it)->ray_intersect(orig, dir, t0, color, N) && t0 < obj_dist) {
				obj_dist = t0;
				hit = orig + dir*t0;
				if (it + 1 == scene->end())
				int j = 1;
			}
		}
		return obj_dist<max_draw;
	}
	
\end{lstlisting}

\begin{lstlisting}[caption=Функция генерации шума Перлина]
unsigned char *Texture::generatePerlinNoise(int octaves){
	unsigned char *img = new unsigned char[n];
	for (int i=0; i<n; i++)
		img[i] = 0;
	
	float norm = 255.0f/INT_MAX;
	std::vector<float> interpolateTable(1 << (octaves));
	for (int j=1; j<=octaves; j++){
		float f = 1<<(octaves-j);
		for (int i=0; i<f; i++){
			float a = ((float)i/f)*M_PI;
			interpolateTable[i] = (1.0f-cosf(a))*0.5f;
		}
		for (int i=0; i<n; i++)
			img[i] += pointOfPerlinNoise(i%w, i/w, f, interpolateTable)*powTable[j]*norm;
	}
	return img;
}
\end{lstlisting}
%\end{center}

\section{Тестирование ПО}
Было проведено тестирование функции \textit{ray\_intersect}, определяющей факт пересечения луча с объектом сцены. Тестирование проводилось для положения камеры в точке с координатами (0, 0, 0) для следующих объектов:
\begin{itemize}
	\item сфера с центром в точке (0, -4, -18) и радиусом 3;
	\item куб с центром в точке (-5, -5, -12) и стороной 4;
	\item цилиндр с серединой основания в точке (0, -2, -12), высотой 4 и радиусом 2.
\end{itemize}

Под понятием <<направление>> понимается точка, лежащая на луче.

\begin{table}[h]
	\begin{center}
		\begin{threeparttable}
			\caption{Результаты тестирования ПО}
			\label{tbl:testing}
			\begin{tabular}{|c|c|c|c|}
				\hline
				{Объект} & {Направление}  & {Ожидаемый результат} & {Фактический результат}\\
				\hline
				Сфера & {(0, -4, -18)} & {True} & {True}\\
				\hline
				Сфера & {(0, -2, -18)} & {True} & {True}\\
				\hline
				Сфера & {(1, -1, -18)} & {True} & {True}\\
				\hline
				Сфера & {(0, 0, -18)} & {False} & {False}\\
				\hline
				Куб & {(-5, -5, -12)} & {True} & {True}\\
				\hline
				Куб & {(-5, -3, -12)} & {True} & {True}\\
				\hline
				Куб & {(-3, -3, -10)} & {True} & {True}\\
				\hline
				Куб & {(0, 0, -1)} & {False} & {False}\\
				\hline
				Цилиндр & {(0, -2, -12)} & {True} & {True}\\
				\hline
				Цилиндр & {(0, 0, -12)} & {True} & {True}\\
				\hline
				Цилиндр & {(2, 0, -12)} & {True} & {True}\\
				\hline
				Цилиндр & {(2.1, 0, -12)} & {False} & {False}\\
				\hline
				
			\end{tabular}
		\end{threeparttable}
	\end{center}
\end{table}

Все тесты пройдены успешно.



\section*{Вывод}
В данном разделе были рассмотрены средства реализации программного продукта, приведены листинги кода реализованных функций, а также результаты тестирования ПО.